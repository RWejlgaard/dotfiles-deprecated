// Generated by CoffeeScript 1.9.1
(function() {
  var deferred, isFunction, isReady, ready, waitUntil, wrapper,
    slice = [].slice;

  var opts = {
    "version": 1,
    "apiEndpoint": "https://api.trello.com",
    "authEndpoint": "https://trello.com",
    "key": "d8c65fac278e6cfc05f5ef3a88aea5c3",
  };

  wrapper = function(window, $, opts) {
    var Trello, apiEndpoint, authEndpoint, authorizeURL, baseURL, collection, fn, fn1, i, j, key, len, len1, localStorage, location, parseRestArgs, readStorage, receiveMessage, ref, ref1, storagePrefix, token, type, version, writeStorage;
    key = opts.key, token = opts.token, apiEndpoint = opts.apiEndpoint, authEndpoint = opts.authEndpoint, version = opts.version;
    baseURL = apiEndpoint + "/" + version + "/";
    location = window.location;
    Trello = {
      version: function() {
        return version;
      },
      key: function() {
        return key;
      },
      setKey: function(newKey) {
        key = newKey;
      },
      token: function() {
        return token;
      },
      setToken: function(newToken) {
        token = newToken;
      },
      rest: function() {
        var args, error, method, params, path, ref, success;
        method = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        ref = parseRestArgs(args), path = ref[0], params = ref[1], success = ref[2], error = ref[3];
        opts = {
          url: "" + baseURL + path,
          type: method,
          data: {},
          dataType: "json",
          success: success,
          error: error
        };
        if (!$.support.cors) {
          opts.dataType = "jsonp";
          if (method !== "GET") {
            opts.type = "GET";
            $.extend(opts.data, {
              _method: method
            });
          }
        }
        if (key) {
          opts.data.key = key;
        }
        if (token) {
          opts.data.token = token;
        }
        if (params != null) {
          $.extend(opts.data, params);
        }
        return $.ajax(opts);
      },
      authorized: function() {
        return token != null;
      },
      deauthorize: function() {
        token = null;
        writeStorage("token", token);
      },
      authorize: function(userOpts) {
        var k, persistToken, ref, regexToken, scope, v;
        opts = $.extend(true, {
          type: "redirect",
          persist: true,
          interactive: true,
          scope: {
            read: true,
            write: false,
            account: false
          },
          expiration: "30days"
        }, userOpts);
        regexToken = /[&#]?token=([0-9a-f]{64})/;
        persistToken = function() {
          if (opts.persist && (token != null)) {
            return writeStorage("token", token);
          }
        };
        if (opts.persist) {
          if (token == null) {
            token = readStorage("token");
          }
        }
        if (token == null) {
          token = (ref = regexToken.exec(location.hash)) != null ? ref[1] : void 0;
        }
        if (this.authorized()) {
          persistToken();
          location.hash = location.hash.replace(regexToken, "");
          return typeof opts.success === "function" ? opts.success() : void 0;
        }
        if (!opts.interactive) {
          return typeof opts.error === "function" ? opts.error() : void 0;
        }
        scope = ((function() {
          var ref1, results;
          ref1 = opts.scope;
          results = [];
          for (k in ref1) {
            v = ref1[k];
            if (v) {
              results.push(k);
            }
          }
          return results;
        })()).join(",");
        switch (opts.type) {
          case "popup":
            (function() {
              var height, left, origin, ref1, top, width;
              waitUntil("authorized", (function(_this) {
                return function(isAuthorized) {
                  if (isAuthorized) {
                    persistToken();
                    return typeof opts.success === "function" ? opts.success() : void 0;
                  } else {
                    return typeof opts.error === "function" ? opts.error() : void 0;
                  }
                };
              })(this));
              width = 420;
              height = 470;
              left = window.screenX + (window.innerWidth - width) / 2;
              top = window.screenY + (window.innerHeight - height) / 2;
              origin = (ref1 = /^[a-z]+:\/\/[^\/]*/.exec(location)) != null ? ref1[0] : void 0;
              return window.open(authorizeURL({
                return_url: origin,
                callback_method: "postMessage",
                scope: scope,
                expiration: opts.expiration,
                name: opts.name
              }), "trello", "width=" + width + ",height=" + height + ",left=" + left + ",top=" + top);
            })();
            break;
          default:
            window.location = authorizeURL({
              redirect_uri: opts.redirectUri || location.href,
              callback_method: "fragment",
              scope: scope,
              expiration: opts.expiration,
              name: opts.name
            });
        }
      }
    };
    ref = ["GET", "PUT", "POST", "DELETE"];
    fn = function(type) {
      return Trello[type.toLowerCase()] = function() {
        return this.rest.apply(this, [type].concat(slice.call(arguments)));
      };
    };
    for (i = 0, len = ref.length; i < len; i++) {
      type = ref[i];
      fn(type);
    }
    Trello.del = Trello["delete"];
    ref1 = ["actions", "cards", "checklists", "boards", "lists", "members", "organizations", "lists"];
    fn1 = function(collection) {
      return Trello[collection] = {
        get: function(id, params, success, error) {
          return Trello.get(collection + "/" + id, params, success, error);
        }
      };
    };
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      collection = ref1[j];
      fn1(collection);
    }
    window.Trello = Trello;
    authorizeURL = function(args) {
      var baseArgs;
      baseArgs = {
        response_type: "token",
        key: key
      };
      return authEndpoint + "/" + version + "/authorize?" + $.param($.extend(baseArgs, args));
    };
    parseRestArgs = function(arg) {
      var error, params, path, success;
      path = arg[0], params = arg[1], success = arg[2], error = arg[3];
      if (isFunction(params)) {
        error = success;
        success = params;
        params = {};
      }
      path = path.replace(/^\/*/, "");
      return [path, params, success, error];
    };
    receiveMessage = function(event) {
      var ref2;
      if (event.origin !== authEndpoint) {
        return;
      }
      if ((ref2 = event.source) != null) {
        ref2.close();
      }
      if ((event.data != null) && event.data.length > 4) {
        token = event.data;
      } else {
        token = null;
      }
      isReady("authorized", Trello.authorized());
    };
    localStorage = window.localStorage;
    if (localStorage != null) {
      storagePrefix = "trello_";
      readStorage = function(key) {
        return localStorage[storagePrefix + key];
      };
      writeStorage = function(key, value) {
        if (value === null) {
          return delete localStorage[storagePrefix + key];
        } else {
          return localStorage[storagePrefix + key] = value;
        }
      };
    } else {
      readStorage = writeStorage = function() {};
    }
    if (typeof window.addEventListener === "function") {
      window.addEventListener("message", receiveMessage, false);
    }
  };

  deferred = {};

  ready = {};

  waitUntil = function(name, fx) {
    if (ready[name] != null) {
      return fx(ready[name]);
    } else {
      return (deferred[name] != null ? deferred[name] : deferred[name] = []).push(fx);
    }
  };

  isReady = function(name, value) {
    var fx, fxs, i, len;
    ready[name] = value;
    if (deferred[name]) {
      fxs = deferred[name];
      delete deferred[name];
      for (i = 0, len = fxs.length; i < len; i++) {
        fx = fxs[i];
        fx(value);
      }
    }
  };

  isFunction = function(val) {
    return typeof val === "function";
  };

  wrapper(window, $, opts);

}).call(this);

//# sourceMappingURL=client.js.map
